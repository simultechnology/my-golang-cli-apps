# Go Pointers Hands-on

Go言語のポインタ、参照型、メモリ管理の挙動を実際にコードを動かしながら学ぶためのハンズオン集です。
C言語など他言語との違い（特に配列やスライスの挙動）に焦点を当てています。

## 実行方法

各ファイルを `go run` で実行して、標準出力の解説を読んでください。

```bash
cd pointer-basics
go run main.go
```

## 学習カリキュラム

### 1. 基礎編

| ファイル | 内容 | 学び |
| --- | --- | --- |
| `main.go` | **ポインタの基本** | `&` でアドレス取得、`*` で値へのアクセス（デリファレンス）。 |
| `mutation.go` | **関数と副作用** | 値渡しはコピーされるため元データが変わらない。書き換えたい場合はポインタ渡しをする。 |
| `person.go` | **メソッドレシーバ** | `func (s *Struct)` は自分自身を書き換えられる。`func (s Struct)` はコピーに対して操作する。 |

### 2. 発展編 (Go言語特有の挙動)

| ファイル | 内容 | 学び |
| --- | --- | --- |
| `nil_safety.go` | **Nilの安全性** | `nil` ポインタへのアクセスはクラッシュするが、`nil` レシーバのメソッド呼び出しは可能（Guard節で安全にできる）。 |
| `reference_types.go` | **参照型** | スライスやマップはポインタ演算子 `*` を使わなくても、参照渡しのように振る舞う（関数内で書き換え可能）。 |

### 3. Deep Dive (上級編)

| ファイル | 内容 | 学び |
| --- | --- | --- |
| `immutable_pattern.go` | **不変性 (Immutability)** | あえて「値レシーバ」を使い、変更ではなく「新しい値を返す」ことで安全性を高めるパターン。 |
| `slice_internals.go` | **スライスの正体** | スライスは「ポインタ・長さ・容量」の3点セット。`append` で容量発生(realloc)するとポインタが変わる罠について。 |
| `array_copy.go` | **配列の正体** | Goの配列 `[N]T` はただの「巨大な値」。代入や関数渡しで全要素がコピーされる（C言語のポインタとは違う）。 |

## 重要なコンセプトまとめ

1. **ポインタは「変数の住所」**
   - 変更を反映させたいとき、巨大な構造体のコピーを避けたいときに使う。
2. **スライス ≠ 配列**
   - 配列は「値」 (コピーされる)。
   - スライスは「窓」 (ポインタを持つ記述子)。実務ではほぼスライスを使う。
3. **特有の罠**
   - `append` を使うときは必ず戻り値を受け取る (`s = append(s, x)`).
   - マップやスライスは関数内で書き換えられることに注意する。
